def bubblesort_once(l):   #7kyu challenge "bubblesort once"
    lst = l.copy()  
    for i in range(len(lst) - 1):  # len(lst) - 1 so it wont go to an unexisting index in the next line 
        if lst[i] > lst[i + 1]:  
            lst[i], lst[i + 1] = lst[i + 1], lst[i]    #switching the values of heighbor indexes
    return lst

def is_sorted_and_how(arr):   #7kyu challenge "sorted? yes? no? how?"
    if arr == sorted(arr):
        return "yes, ascending"
    elif arr == sorted(arr, reverse = True):
        return "yes, descending"
    else:
        return "no"
    pass  

def pattern(n: int) -> str:   #7kyu challenge "complete the pattern #7 - cyclical permutation"
    if n <= 0:
        return ""
    
    sol = ""
    for start in range(1, n + 1):
        m = start
        count = 0
        while count < n:
            if m > n:
                m = 1  
            sol += str(m)
            m += 1
            count += 1
        if start != n:
            sol += "\n"
    return sol
def square_digits(num):   #7kyu challenge "square every digit"
    return int("".join(str(int(element)*int(element)) for element in str(num)))

def xo(s):   #7kyu challenge "exes and ohs"
    cnto = 0
    cntx = 0
    for element in s:
        if element == "o" or element == "O":
            cnto += 1
        elif element == "x" or element == "X":
            cntx += 1
    return cnto == cntx

def spin_words(sentence):   #6 kyu challenge "stop gninnips my sdrow!"
    sen = sentence.split(" ")
    for i in range(len(sen)):
        if len(sen[i]) >= 5:
            sen[i] = sen[i][::-1]
    return " ".join(sen)

def digital_root(n):   #6kyu challenge "sum of digits / digital root"
    bibka = sum([int(digit) for digit in str(n)])
    if bibka >= 10:
        return digital_root(bibka)
    else:
        return bibka

def letters_to_numbers(s):   #6kyu challenge "sentence calculator"
    score = 0
    uneffective1 = "@abcdefghijklmnopqrstuvwxyz"
    uneffective2 = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    for element in s:
        if element in uneffective1:
            score += uneffective1.index(element)
        elif element in uneffective2:
            score += uneffective2.index(element)*2
        elif element.isdigit():
            score += int(element)
    return score
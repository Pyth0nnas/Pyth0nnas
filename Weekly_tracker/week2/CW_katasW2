def bubblesort_once(l):   #7kyu challenge "bubblesort once"
    lst = l.copy()  
    for i in range(len(lst) - 1):  # len(lst) - 1 so it wont go to an unexisting index in the next line 
        if lst[i] > lst[i + 1]:  
            lst[i], lst[i + 1] = lst[i + 1], lst[i]    #switching the values of heighbor indexes
    return lst

def is_sorted_and_how(arr):   #7kyu challenge "sorted? yes? no? how?"
    if arr == sorted(arr):
        return "yes, ascending"
    elif arr == sorted(arr, reverse = True):
        return "yes, descending"
    else:
        return "no"
    pass  

def pattern(n: int) -> str:   #7kyu challenge "complete the pattern #7 - cyclical permutation"
    if n <= 0:
        return ""
    
    sol = ""
    for start in range(1, n + 1):
        m = start
        count = 0
        while count < n:
            if m > n:
                m = 1  
            sol += str(m)
            m += 1
            count += 1
        if start != n:
            sol += "\n"
    return sol
def square_digits(num):   #7kyu challenge "square every digit"
    return int("".join(str(int(element)*int(element)) for element in str(num)))

def xo(s):   #7kyu challenge "exes and ohs"
    cnto = 0
    cntx = 0
    for element in s:
        if element == "o" or element == "O":
            cnto += 1
        elif element == "x" or element == "X":
            cntx += 1
    return cnto == cntx

def spin_words(sentence):   #6 kyu challenge "stop gninnips my sdrow!"
    sen = sentence.split(" ")
    for i in range(len(sen)):
        if len(sen[i]) >= 5:
            sen[i] = sen[i][::-1]
    return " ".join(sen)

def digital_root(n):   #6kyu challenge "sum of digits / digital root"
    bibka = sum([int(digit) for digit in str(n)])
    if bibka >= 10:
        return digital_root(bibka)
    else:
        return bibka

def letters_to_numbers(s):   #6kyu challenge "sentence calculator"
    score = 0
    uneffective1 = "@abcdefghijklmnopqrstuvwxyz"
    uneffective2 = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    for element in s:
        if element in uneffective1:
            score += uneffective1.index(element)
        elif element in uneffective2:
            score += uneffective2.index(element)*2
        elif element.isdigit():
            score += int(element)
    return score

def vowel_recognition(s):   #6kyu challenge "vowel recognition"
    vowels = set("aeiouAEIOU")
    n = len(s)
    total = 0
    
    for i, char in enumerate(s):
        if char in vowels:
            total += (i + 1) * (n - i)
    
    return total

def count_digits(num, rounds):   #6kyu challenge "counting digits"
    current = str(num)
    order = []
    seen = set()
    for digit in current:
        if digit not in seen:
            seen.add(digit)
            order.append(digit)
    counts = {}
    for digit in current:
        counts[digit] = counts.get(digit, 0) + 1
    result_parts = []
    for i, digit in enumerate(order):
        result_parts.append(str(counts[digit]))  
        result_parts[i] += order[i]  
    if rounds - 1 == 0:
        return [int(element) for element in result_parts]
    new_num = "".join(result_parts)
    return count_digits(int(new_num), rounds - 1)

def find_outlier(integers):  #6kyu challenge "find the parity outlier"
    cntodd = 0
    cnteven = 0
    for i in range(len(integers)):
        if integers[i] % 2 == 0:
            cnteven += 1
        else:
            cntodd += 1
    if cnteven > cntodd:
        for i in range(len(integers)):
            if integers[i] % 2 == 1:
                return integers[i]
    else:
        for i in range(len(integers)):
            if integers[i] % 2 == 0:
                return integers[i]
            
def count_bits(n):   #6kyu challenge "bit counting"
    return str(format(n, "b")).count("1")

def palindrome(text):
    unwanted = " (){/\:.'\"'*-+&}^%$#@!?=><;,_"
    for char in unwanted:
        text = text.replace(char, '')
    return text.lower() == text[::-1].lower()

def split_integer(num, parts):   #6kyu challenge "almost even"
    result = []
    if num % parts == 0:
        for i in range(0, parts):
            result.append(num//parts)
    elif parts > num:
        while parts != 0:
            if num != 0:
                result.append(1)
                num -= 1
            else:
                result.append(0)
            parts -= 1
    else:
        for i in range(0, parts):
            result.append(num//parts)
        n = -1
        nn = num % parts
        while nn != 0:
            result[n] += 1
            nn -= 1
            n -=1
    return result

def delete_nth(order,max_e):   #6kyu challenge "delete occurrences of an element if it occurs more than n times"
    allcounts = {}
    sol = []
    for element in order:
        if element not in allcounts:
            allcounts[element] = 0
    for element in order:
        if allcounts[element] != max_e:
            sol.append(element)
            allcounts[element] += 1
    return sol
    
class Cipher:   # 6kyu kata - "Simple Substitution Cipher Helper"
    def __init__(self, map1, map2):
        self.map1 = map1
        self.map2 = map2
    def encode(self, string):
        encoded = ""
        for element in string:
            if element in self.map1:
                encoded += self.map2[self.map1.index(element)]   # adding to the result the letter from the same position in map2 
            else:
                encoded += element
        return encoded
    def decode(self, string):
        decoded = ""
        for element in string:
            if element in self.map2:
                decoded += self.map1[self.map2.index(element)]   # same thing as before but switching between map1 and map2
            else:
                decoded += element
        return decoded
    
def most_money(students):   # 6kyu kata - "Who has the most money?"
    equality = 1
    mostmoney = 0
    if len(students) == 1:
        return students[0].name
    for i in range(len(students)):
        money = students[i].fives * 5 + students[i].tens * 10 + students[i].twenties * 20   # counting the total amount for each student
        if money == mostmoney: 
            equality += 1   # if the two students have the same amount get 1 equality point
        if money > mostmoney:
            mostmoney = money   # getting the biggest amount
    if equality >= len(students):    # if there is same amount of equality points as the students that means each has the same amount of money 
        return "all"
    for i in range(len(students)):
        money = students[i].fives * 5 + students[i].tens * 10 + students[i].twenties * 20
        if money == mostmoney:   # finding the student with the biggest amount of money
            return students[i].name
        
class Lamp:    # 6kyu kata - "The Lamp: Revisited"
    def __init__(self, color: str, on: bool = False):
        self.color = color
        self.on = on
    def on(self):    # simple check
        if self.on:
            return True
        if not self.on:
            return False
    def color(self):   # simple getter
        return self.color
    def toggle_switch(self):
        if self.on:
            self.on = False
        else:
            self.on = True
    def state(self):    # simple "__str__"
        if self.on:
            return "The lamp is on."
        return "The lamp is off."
    
class Harshad:   # 6kyu kata - "Harshad or Niven numbers"
    @staticmethod
    def is_valid(number):   # checking if the number meets the requerments to be "Harshad"
        digsum = 0
        for dig in str(number):
            digsum += int(dig)
        if number % digsum == 0:
            return True
        return False
    @staticmethod
    def get_next(number):    # finding the next "harshad" number starting from "number"
        next = number + 1
        while not Harshad.is_valid(next):
            next += 1
        return next
    @staticmethod
    def get_series(count, start=0):   # getting the needed amount of "Harshad numbers" after "number"
        nextseries = [start]
        counter = 0
        while count + 1 != len(nextseries):
            nextseries.append(Harshad.get_next(nextseries[counter]))
            counter += 1
        return nextseries[1:]
    
class SmartTrafficLight:   # 6kyu kata - "Smart Traffic Lights"
    def __init__(self, st1, st2):
        self.st1 = st1
        self.st2 = st2
        
    def turngreen(self):   # simple...
        if self.st1[0] > self.st2[0]:
            self.st1[0] = 0
            return self.st1[1]
        elif self.st1[0] < self.st2[0]:
            self.st2[0] = 0
            return self.st2[1]
        else:
            return None
        
class HighScoreTable:   # 6kyu kata - "High score table"
    
    def __init__(self, length):
        self.scores = []
        self.length = length
    def update(self, score):
        self.scores.append(score)
        self.scores = sorted(self.scores, reverse = True)   # sorting the leaderboard after every new score
        if len(self.scores) > self.length:
            self.scores = self.scores[:self.length]   # cutting the scores that beyond the leaderboard len
    def reset(self):   # reset...
        self.scores.clear()
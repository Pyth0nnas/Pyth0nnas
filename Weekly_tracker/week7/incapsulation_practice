class CoffeeMachine:
    def __init__(self):
        self._water_level = 0
        self._coffee_level = 0
        self._trash_level = 0
        self._cups_quantity = 0
        self.water_capacity = 1000
        self.coffee_capacity = 500
        self.trash_bin_capacity = 300
    def add_water(self, amount: float):
        if amount <= 0:
            raise ValueError("Error - incorrect amount")
        if amount > self.water_capacity-self._water_level:
            raise ValueError("operation cancelled - there is not enough capacity in the water tank")
        self._water_level += amount
        return f"succesful operation - now water level is {self._water_level}"
    def add_coffee_beans(self, amount: float):
        if amount <= 0:
            raise ValueError("Error - incorrect amount")
        if amount > self.coffee_capacity-self._coffee_level:
            raise ValueError("operation cancelled - there is not enough capacity in the coffee beans tank")
        self._coffee_level += amount
        return f"succesful operation - now coffee level is {self._coffee_level}"
    def make_coffee(self):
        if self._water_level < 200 or self._coffee_level < 20 or self._trash_level == self.trash_bin_capacity:
            raise ValueError("operation cancelled - there is not enough ingridients or the trash bin is full")
        self._cups_quantity += 1
        self._water_level -= 200
        self._coffee_level -= 20
        self._trash_level += 15
        return f"operation succesful - your coffee is being prepared"
    def clean_waste_container(self):
        if self._trash_level == 0:
            raise ValueError("operation cancelled - the trash bin is aleady empty")
        self._trash_level = 0
        return f"operation succesful - the trash bin is empty now"
    def get_status(self):
        return f"current water level - {self._water_level}\ncurrent coffee level - {self._coffee_level}\ncurrent trash level - {self._trash_level}\ntotal amount of coffee cups prepared - {self._cups_quantity}"

class Library:
    def __init__(self):
        self.__books = []
        self.__users = []
        pass
    
    def add_book(self, isbn, title, author, year):
        if self._validate_isbn(isbn):
            self.__books.append({"ISBN": isbn, "title": title, "author": author, "year": year})
            return "Book has been succesfully added"
        raise TypeError("ISBN must be a number")

    
    def register_user(self, user_id, name):
        if self._validate_user(user_id):
            self.__users.append({"ID": user_id, "name": name, "borrowed_books": []})
            return "User has been succesfully added"
        return TypeError("User ID must be a number")
    
    def borrow_book(self, user_id, isbn):
        if self._validate_user(user_id) and self._validate_isbn(isbn):
            user_exists = any(user["ID"] == user_id for user in self.__users)
            book_exists = any(book["ISBN"] == isbn for book in self.__books)
            if user_exists and book_exists:
                if self._is_available(isbn):
                    for user in self.__users:
                        if user_id == user["ID"]:
                            if len(user["borrowed_books"]) < 3:
                                user["borrowed_books"].append(isbn)
                                return "You have succesfully borrowed this book"
                            return "book cannot be borrowed, you have reached borrowing limit"
                return "This book is currently unawailable"
            raise ValueError("There is no such ISBN or user ID")
        raise TypeError("User ID and ISBN must be numbers")

    def return_book(self, user_id, isbn):
        if self._validate_user(user_id) and self._validate_isbn(isbn):
            user_exists = any(user["ID"] == user_id for user in self.__users)
            book_exists = any(book["ISBN"] == isbn for book in self.__books)
            if user_exists and book_exists:
                for user in self.__users:
                    if isbn in user["borrowed_books"]:
                        user["borrowed_books"].remove(isbn)
                        return "This book has been returned"
            raise ValueError("There is no such ISBN or user ID")
        raise TypeError("User ID and ISBN must be numbers")
    
    def remove_book(self, isbn):
        if self._validate_isbn(isbn):
            for i,book in enumerate(self.__books):
                if book["ISBN"] == isbn:
                    self.__books.pop(i)
                    return "Book has been removed"
            return ValueError("There is no such a book")
        raise TypeError("ISBN must be a number")
    
    def remove_user(self, user_id):
        if self._validate_user(user_id):
            for i,user in enumerate(self.__users):
                if user["ID"] == user_id:
                    self.__users.pop(i)
                    return "User has been removed"
            raise ValueError("There is no such user ID") 
        raise TypeError("User ID must be a number")
    
    def get_statistics(self):
        return f"there is {len(self.__books)} books in the library, they are {self.__books}, also there is {len(self.__users)} users in this library, their personal information is confident"
    
    def _validate_isbn(self, isbn):
        if type(isbn) == int:
            return True
        else:
            return False
    
    def _validate_user(self, user_id):
        if type(user_id) == int:
            return True
        else:
            return False
    def _is_awailable(self, isbn):
        for user in self.__users:
            if isbn in user["borrowed_books"]:
                return False
        return True
    
from abc import ABC, abstractmethod

class Employee(ABC):
    def __init__(self, first_name, last_name, email, default_salary):
        self._first_name = first_name
        self._last_name = last_name
        self._default_salary = default_salary
        self._email = email
    @property
    def email(self):
        if type(self.email, str):
            return self._email
        raise TypeError("Wrong input type")

    @property
    def default_salary(self):
        if type(self.default_salary, int):
            return self.default_salary
        raise TypeError("Wrong input type")
    
    @property 
    def full_name(self):
        if type(self._first_name, str) and type(self._last_name, str):
            return f"{self._first_name} {self._last_name}"
        raise TypeError("Wrong input type")
    
    @abstractmethod
    def calculate_salary(self):
        pass

class HourlyEmployee(Employee):
    def __init__(self, first_name, last_name, email, default_salary, hourly_rate):
        super().__init__(first_name, last_name, email, default_salary)
        self._hourly_rate = hourly_rate
        self._hours_worked = 0
    
    @property
    def hourly_rate(self):
        if type(self._hourly_rate, int):
            return self._hourly_rate
        elif type(self._hourly_rate, str):
            return int(self._hourly_rate)
        raise TypeError("Wrong input type")
    
    @hourly_rate.setter
    def hourly_rate(self, value):
        if type(value, int):
            if value > 0:
                self._hourly_rate = value
    
    @property
    def hours_worked(self):
        if type(self._hours_worked, int):
            return self._hours_worked
        elif type(self._hours_worked, str):
            return int(self._hours_worked)
        raise TypeError("Wrong input type")
    
    @hours_worked.setter
    def hours_worked(self, value):
        if type(value, int):
            if value > 0:
                self._hours_worked = value
    
    def calculate_salary(self):
        if self._hours_worked <= 40:
            return self._hours_worked*self._hourly_rate
        else:
            return self._hourly_rate*40+self._hourly_rate*1.5*(self._hours_worked-40)
        
class SalariedEmployee(Employee):
    def __init__(self, first_name, last_name, email, default_salary, experience):
        super().__init__(first_name, last_name, email, default_salary)
        self._experience = experience
    @property
    def experience(self):
        if type(self._experience, int):
            return self._experience
        raise TypeError("Wrong input type")
    
    @experience.setter
    def experience(self, value):
        if type(value, int):
            if value >= 0:
                self._experience = value

    def calculate_salary(self):
        if self._experience == 0:
            return self._default_salary
        if self._experience < 20:
            return self._default_salary+(self._default_salary*self._experience/100)
        if self._experience >= 20:
            return self._default_salary+(self._default_salary/5)

class ComissionEmployee(SalariedEmployee):
    def __init__(self, first_name, last_name, email, default_salary, experience, sells):
        super().__init__(first_name, last_name, email, default_salary, experience)
        self._sells = sells
    
    @property
    def sells(self):
        if type(self._sells, int):
            return self._experience
        raise TypeError("Wrong input type")
    
    @sells.setter
    def sells(self, value):
        if type(value, int):
            if value >= 0:
                self._sells = value

    def calculate_salary(self):
        return super().calculate_salary()+(self.sells*5/100)
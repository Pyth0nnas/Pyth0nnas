class CoffeeMachine:
    def __init__(self):
        self._water_level = 0
        self._coffee_level = 0
        self._trash_level = 0
        self._cups_quantity = 0
        self.water_capacity = 1000
        self.coffee_capacity = 500
        self.trash_bin_capacity = 300
    def add_water(self, amount: float):
        if amount <= 0:
            raise ValueError("Error - incorrect amount")
        if amount > self.water_capacity-self._water_level:
            raise ValueError("operation cancelled - there is not enough capacity in the water tank")
        self._water_level += amount
        return f"succesful operation - now water level is {self._water_level}"
    def add_coffee_beans(self, amount: float):
        if amount <= 0:
            raise ValueError("Error - incorrect amount")
        if amount > self.coffee_capacity-self._coffee_level:
            raise ValueError("operation cancelled - there is not enough capacity in the coffee beans tank")
        self._coffee_level += amount
        return f"succesful operation - now coffee level is {self._coffee_level}"
    def make_coffee(self):
        if self._water_level < 200 or self._coffee_level < 20 or self._trash_level == self.trash_bin_capacity:
            raise ValueError("operation cancelled - there is not enough ingridients or the trash bin is full")
        self._cups_quantity += 1
        self._water_level -= 200
        self._coffee_level -= 20
        self._trash_level += 15
        return f"operation succesful - your coffee is being prepared"
    def clean_waste_container(self):
        if self._trash_level == 0:
            raise ValueError("operation cancelled - the trash bin is aleady empty")
        self._trash_level = 0
        return f"operation succesful - the trash bin is empty now"
    def get_status(self):
        return f"current water level - {self._water_level}\ncurrent coffee level - {self._coffee_level}\ncurrent trash level - {self._trash_level}\ntotal amount of coffee cups prepared - {self._cups_quantity}"

class Library:
    def __init__(self):
        self.__books = []
        self.__users = []
        pass
    
    def add_book(self, isbn, title, author, year):
        if isbn._validate_isbn():
            self.__books.append({"ISBN": isbn, "title": title, "author": author, "year": year})
            return "Book has been succesfully added"
        raise TypeError("ISBN must be a number")

    
    def register_user(self, user_id, name):
        if user_id._validate_user():
            self.__users.append({"ID": user_id, "name": name, "borrowed_books": []})
            return "User has been succesfully added"
        return TypeError("User ID must be a number")
    
    def borrow_book(self, user_id, isbn):
        if user_id._validate_user() and isbn._validate_isbn():
            user_exists = any(user["ID"] == user_id for user in self.__users)
            book_exists = any(book["ISBN"] == isbn for book in self.__books)
            if user_exists and book_exists:
                if isbn._is_available():
                    for user in self.__users:
                        if user_id == user["ID"]:
                            if len(user["borrowed_books"]) < 3:
                                user["borrowed_books"].append(isbn)
                                return "You have succesfully borrowed this book"
                            return "book cannot be borrowed, you have reached borrowing limit"
                return "This book is currently unawailable"
            raise ValueError("There is no such ISBN or user ID")
        raise TypeError("User ID and ISBN must be numbers")

    def return_book(self, user_id, isbn):
        if user_id._validate_user() and isbn._validate_isbn():
            user_exists = any(user["ID"] == user_id for user in self.__users)
            book_exists = any(book["ISBN"] == isbn for book in self.__books)
            if user_exists and book_exists:
                for user in self.__users:
                    if isbn in user["borrowed_books"]:
                        user["borrowed_books"].remove(isbn)
                        return "This book has been returned"
            raise ValueError("There is no such ISBN or user ID")
        raise TypeError("User ID and ISBN must be numbers")
    
    def remove_book(self, isbn):
        if isbn._validate_isbn():
            for i,book in enumerate(self.__books):
                if book["ISBN"] == isbn:
                    self.__books.pop(i)
                    return "Book has been removed"
            return ValueError("There is no such a book")
        raise TypeError("ISBN must be a number")
    
    def remove_user(self, user_id):
        if user_id._validate_user():
            for i,user in enumerate(self.__users):
                if user["ID"] == user_id:
                    self.__users.pop(i)
                    return "User has been removed"
            raise ValueError("There is no such user ID") 
        raise TypeError("User ID must be a number")
    
    def get_statistics(self):
        return f"there is {len(self.__books)} books in the library, they are {self.__books}, also there is {len(self.__users)} users in this library, their personal information is confident"
    
    def _validate_isbn(self, isbn):
        if type(isbn) == int:
            return True
        else:
            False
    
    def _validate_user(self, user_id):
        if type(user_id) == int:
            return True
        else:
            False
    def _is_awailable(self, isbn):
        for user in self.__users:
            if isbn in user["borrowed_books"]:
                return False
        return True